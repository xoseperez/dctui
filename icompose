#!/bin/env python3

import os
import sys
import time
import flatdict
import yaml
import logging
import json
import socket
import subprocess
import random
import string
import shutil

# -----------------------------------------------------------------------------
# Globals
# -----------------------------------------------------------------------------

APP_NAME = "iCOMPOSE"
APP_DESCRIPTION = "Interactive Docker Compose Utility"
APP_VERSION = "v0.0.1"

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

class Config():

    _data = flatdict.FlatDict({})
    _args = None
    _dirty = False

    def __init__(self, file=None, args={}):
        
        try:
            with open(file or "config.yml", "r") as f:
                _data =  yaml.load(f, Loader=yaml.loader.SafeLoader)
        except FileNotFoundError:
            _data = {'logging': {'level' : logging.INFO}}
        
        self._data = flatdict.FlatDict(_data, delimiter='.')

        # filter out "None" values
        for key in self._data:
            if self._data[key] == None:
                del self._data[key]

        self._args = args

    def get(self, key, default=None):
        
        # External name
        env_name = key.upper().replace('.', '_').replace('-', '_')

        # Arguments have precedence over `config.yml` but do not get persisted
        value = self._args.get(env_name, None)
        
        # Environment variables have precedence over `config.yml` but do not get persisted
        if value is None:
            value = os.environ.get(env_name, None)
        
        # Get the value from `config.yml` or the default
        if value is None:
            value = self._data.get(key)

        if value is None:
            value = default

        return value

    def set(self, key, value):
        if self._data.get(key) != value:
            self._data[key] = value
            self._dirty = true

    def save(self):
        if self._dirty:
            try:
                with open(self._file, "w") as f:
                    yaml.dump(self._data.as_dict(), f, default_flow_style=False)
                self._dirty = False
            except FileNotFoundError:
                None

    def unflat(self):
        return self._data.as_dict()

    def dump(self):
        print(json.dumps(self._data.as_dict(), sort_keys=True, indent=4))


# -----------------------------------------------------------------------------
# Utils
# -----------------------------------------------------------------------------

class color:

    black = "\033[90m"
    red = "\033[91m"
    green = "\033[92m"
    orange = "\033[93m"
    blue = "\033[94m"
    purple = "\033[95m"
    cyan = "\033[96m"
    white = "\033[97m"
    
    reset = '\033[0m'
    bold = "\033[1m"
    underline = "\033[4m"
    reverse = "\033[7m"
    clear = "\033[2J\033[H"

    ask = orange
    error = red
    info = green
    header = blue


def get_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(0)
    try:
        # doesn't even have to be reachable
        s.connect(('8.8.8.8', 1))
        IP = s.getsockname()[0]
    except Exception:
        IP = '127.0.0.1'
    finally:
        s.close()
    return IP

def get_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str
    
def replace_placeholders(value, envs={}):
    if isinstance(value, str):
        value = value.replace("[[IP]]", get_ip())
        value = value.replace("[[RANDOM16]]", get_random_string(16))
        value = value.replace("[[RANDOM32]]", get_random_string(32))
        for option in envs:
            value = value.replace(f"[[{option}]]", str(envs[option]))
    return value

def show_header(text):
    print(f"{color.header}-----------------------------------------------------------------{color.reset}")
    print(f"{color.header}{color.bold}{text}{color.reset}")
    print(f"{color.header}-----------------------------------------------------------------{color.reset}")

def show_menu(title, options):

    error = False
    num_options = len(options)
    if num_options == 0:
        return 0

    while (True):
    
        print(f"{color.reset}")
        if error:
            print(f"{color.error}{color.bold}Invalid option. Try again.{color.reset}\n") 
            error = False 
        show_header(title)         
        for index in range(num_options):
            name = options[index]['name']
            description = options[index].get('description',None)
            print(f"[{color.ask}{index+1:2d}{color.reset}] {name.title()} {color.info+'('+description+')'+color.reset if description else ''}")

        try:
            ans = int(input(f"\n{color.ask}Choose option: {color.white}"))
            if (0 < ans) and (ans <= num_options):
                return ans-1
        except KeyboardInterrupt:
            sys.exit(1)
        except:
            ans = 0
        error = True
       
def input_field(title, default):

    default = replace_placeholders(default)
    prompt=f"{title} [{default}]"
    try:
        ans = input(f"{color.ask}{prompt}: {color.white}") or default
    except KeyboardInterrupt:
        sys.exit(1)

    return ans

def input_select(title, default, options):

    num_options = len(options)

    try:
        default = options.index(default)
    except ValueError:
        default = 1
    
    print(f"{color.ask}{title}:{color.reset}")
    for index in range(num_options):
        print(f"[{color.ask}{index+1:2d}{color.reset}] {options[index]}")
    
    ans=0
    while 0 == ans:
        try:
            ans = int(input_field("Select option", default+1))
            if (ans < 1) or (ans > num_options):
                ans = 0
        except KeyboardInterrupt:
            sys.exit(1)
        except:
            ans = 0

    return options[ans-1]

def input_confirm(prompt):

    try:
        ans = input(f"{color.ask}{prompt} [y/N]: {color.white}") or 'N'
    except KeyboardInterrupt:
        sys.exit(1)

    return ans.upper() == 'Y'

# -----------------------------------------------------------------------------
# Stack manipulation
# -----------------------------------------------------------------------------

def get_stack_by_id(project):
    global stacks
    for stack in stacks:
        if stack['project'] == project:
            return stack
    return None

def read_stack_files(config):
    
    stacks=[]

    try:
        folders=[x[0] for x in os.walk(config.get('stacks.folder'))]
        folders.sort()
    except:
        folders=[]
    
    for folder in folders:
        files = os.listdir(folder)
        for file in files:
            file = folder + "/" + file
            if not os.path.isfile(file):
                continue
            if not file.endswith(".yml") and not file.endswith(".yaml"):
                continue
            data={}
            with open(file, 'r') as h:
                data = yaml.safe_load(h)
            if "x-icompose" in data:
                project = folder.split('/')[-1]
                stacks.append({
                    "project": project,
                    "group": data['x-icompose'].get('group', 'generic').lower(),
                    "file": file,
                    "data": data['x-icompose'],
                })
    
    return stacks

'''
TODO: check if we have write permissions to the stack file
'''
def write_stack_files(project, defaults):
    
    global stacks
    stack = get_stack_by_id(project)
    file = stack['file']
    print(f"{color.blue}Saving {defaults} to {file}{color.reset}")

    # Backup original file
    if not os.path.isfile(f"{file}.original"):
        shutil.copy(file, f"{file}.original")
    
    # Saving to cache
    for field in stack['data']['fields']:
        if field['name'] in defaults:
            field['default'] = defaults[field['name']]

    # Saving to file
    with open(file, 'r') as h:
        data = yaml.safe_load(h)
    for field in data['x-icompose']['fields']:
        if field['name'] in defaults:
            field['default'] = defaults[field['name']]
    with open(file, 'w') as h:
        yaml.dump(data, h, default_flow_style=False, sort_keys=False)    


def get_existing_stacks():
    stacks = []
    try:
        command="docker compose ls -a --format json"
        p = subprocess.run(command, shell=True, capture_output=True)
        output = json.loads(p.stdout.decode().strip())
        for stack in output:
            stacks.append({
                'name': stack['Name'],
                'running': (stack['Status']).startswith('running')
            })
    except:
        None
    return stacks


# -----------------------------------------------------------------------------
# Menus
# -----------------------------------------------------------------------------

def configure_stack_menu(project):

    # Header
    print()
    stack = get_stack_by_id(project)
    show_header(f"Configure '{stack['data']['name']}'")

    # Get project
    project = input_field("Stack name", stack['project'])

    # Get fields
    envs = {}
    allow_advanced = None
    fields = stack.get('data', {}).get('fields', [])
    for field in fields:
        
        description = field.get('description', field.get('name'))
        default = field.get('default', '')

        # Check if it is an Advanced field
        advanced = field.get('advanced', False)
        if advanced and allow_advanced == None:
            allow_advanced = input_confirm('Configure advanced settings')
        if advanced and allow_advanced == False:
            envs[field['name']] = replace_placeholders(default)
            continue
        
        # Show prompt
        if 'options' in field:
            envs[field['name']] = input_select(description, default, field.get('options', [default]))
        else:
            envs[field['name']] = input_field(description, default)

    # Start stack
    print(f"\n{color.info}I will start the {project} stack using this configuration:\n{envs}{color.reset}")
    proceed = input_confirm("Proceed?")
    if proceed:
        
        # Run stack
        print(f"{color.info}\nBringing up {project} stack{color.reset}")
        env_string = ' '.join([f"{key}={envs[key]}" for key in envs])
        command = f"{env_string} docker compose -f {stack['file']} -p {project} up -d"
        p = subprocess.run(command, shell=True)
        if p.returncode == 0:
            print(f"{color.info}\nService succesfully started{color.reset}")
            if 'success' in stack['data']:
                print(f"{color.info}{replace_placeholders(stack['data']['success'], envs)}{color.reset}")
        else:
            print(f"{color.error}\nError starting service{color.reset}")
            command = f"docker compose -p {project} down"
            p = subprocess.run(command, shell=True)

    # Save default
    proceed = input_confirm("\nSave this values?")
    if proceed:
        write_stack_files(stack['project'], envs)
    

def manage_stack_menu(stack):

    options = [{'name': option} for option in [f"{'Stop' if stack['running'] else 'Start'}", 'Destroy', 'Logs', 'Exit']]

    while (True):
        selected = show_menu(f"Manage stack {stack['name']}", options)
        if 0 == selected:
            command=f"docker compose -p {stack['name']} {'stop' if stack['running'] else 'start'}"
            p = subprocess.run(command, shell=True)
            return True
        elif 1 == selected:
            command=f"docker compose -p {stack['name']} down"
            p = subprocess.run(command, shell=True)
            return True
        elif 2 == selected:
            command=f"docker compose -p {stack['name']} logs -f"
            try:
                p = subprocess.run(command, shell=True)
            except KeyboardInterrupt:
                None
            except:
                sys.exit(1)
        else:
            return False

def available_stacks_menu(group="generic"):

    global stacks
    options=[ {"project": stack['project'], "name": stack['data']['name'], "description": stack['data'].get('description', '')} for stack in stacks if (stack['group'] == group)]
    options.append({'name': 'Exit'})

    while (True):
        selected = show_menu("Select stack", options)
        if selected < len(options)-1:
            configure_stack_menu(options[selected]['project'])
        else:
            return

def groups_menu():

    global groups
    options=[{"name": group} for group in groups]
    options.append({'name': 'Exit'})

    while (True):
        selected = show_menu("Select group", options)
        if selected < len(options)-1:
            available_stacks_menu(options[selected]['name'].lower())
        else:
            return

def existing_stacks_menu():

    options = get_existing_stacks()
    options.append({'name': 'Exit'})

    while (True):
        selected = show_menu("Existing stacks", options)
        if selected < len(options)-1:
            if manage_stack_menu(options[selected]):
                return
        else:
            return

def main_menu():

    options=[
        {'name': "Create stack"},
        {'name': "Manage stacks"},
        {'name': "Exit"},
    ]

    while (True):
        selected = show_menu("Main menu", options)
        if 0 == selected:
            global groups
            if 1 == len(groups):
                available_stacks_menu(groups[0])
            else:
                groups_menu()
        elif 1 == selected:
            existing_stacks_menu()
        else:
            return


# -----------------------------------------------------------------------------
# Entrypoint
# -----------------------------------------------------------------------------

if __name__ == "__main__":
    
    # Welcome message
    print(f"\n{color.header}{color.bold}{APP_NAME} {APP_VERSION}{color.reset}")
    print(f"{color.header}{APP_DESCRIPTION}{color.reset}")
    print(f"{color.header}(c) Xose Pérez <xose.perez@gmail.com>{color.reset}")

    # Load configuration file
    # TODO: get rid of config, look for the stacks in given location of the system and merge them
    config = Config('config.yml')

    # Load stacks
    stacks = read_stack_files(config)
    groups = list(set([stack['group'] for stack in stacks]))
    groups.sort()

    # Show menu
    main_menu()

    # Bye
    print(f"\n{color.green}Bye!{color.reset}\n")




